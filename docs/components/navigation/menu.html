---
layout: components
title: Menu 菜单
group: navigation
---

<h2>列表菜单</h2>

<h3>静态展示</h3>
<section class="component-container" style="height: 280px;">
  <div class="list-menu list-menu-open">
    <ul class="list-menu-items list">
      <li class="list-item">Undo</li>
      <li class="list-item">Redo</li>
      <li class="list-divider"></li>
      <li class="list-item">Cut</li>
      <li class="list-item">Copy</li>
      <li class="list-item">Paste</li>
      <li class="list-divider"></li>
      <li class="list-item">Paste from History...</li>
    </ul>
  </div>
</section>

<h3>显示菜单</h3>
<section class="component-container">
  <div class="d-inline-flex align-items-center">
    <label class="menu-demo-label">菜单位置:</label>
    <div class="form-field">
      <div class="radio radio-primary">
        <input class="radio-native-control" type="radio" name="position" value="top left" id="top_left" checked/>
        <div class="radio-background">
          <div class="radio-circle-outer"></div>
          <div class="radio-circle-inner"></div>
        </div>
      </div>
      <label for="top_left">Top left</label>
    </div>

    <div class="form-field">
      <div class="radio radio-primary">
        <input class="radio-native-control" type="radio" name="position" value="top right" id="top_right"/>
        <div class="radio-background">
          <div class="radio-circle-outer"></div>
          <div class="radio-circle-inner"></div>
        </div>
      </div>
      <label for="top_right">Top right</label>
    </div>

    <div class="form-field">
      <div class="radio radio-primary">
        <input class="radio-native-control" type="radio" name="position" value="bottom left" id="bottom_left"/>
        <div class="radio-background">
          <div class="radio-circle-outer"></div>
          <div class="radio-circle-inner"></div>
        </div>
      </div>
      <label for="bottom_left">Bottom left</label>
    </div>
    <div class="form-field">
      <div class="radio radio-primary">
        <input class="radio-native-control" type="radio" name="position" value="bottom right" id="bottom_right"/>
        <div class="radio-background">
          <div class="radio-circle-outer"></div>
          <div class="radio-circle-inner"></div>
        </div>
      </div>
      <label for="bottom_right">Bottom right</label>
    </div>
  </div>

  <div class="menu-demo-panel">
    <div class="menu-demo-position">
      <button class="btn btn-secondary btn-raised" id="toggleMenu">显示菜单</button>
      <div class="list-menu" id="listMenuDemo">
        <ul class="list-menu-items list">
          <li class="list-item">Undo</li>
          <li class="list-item">Redo</li>
          <li class="list-divider"></li>
          <li class="list-item">Cut</li>
          <li class="list-item">Copy</li>
          <li class="list-item">Paste</li>
          <li class="list-divider"></li>
          <li class="list-item">Paste from History...</li>
        </ul>
      </div>
    </div>
  </div>
</section>

<div class="component-wrap">
  <section class="component-container">
    <h3> 普通菜单 </h3>
    <ul class="menu">
      <li>
        <a href="#" class="menu-title menu-header">menu-1</a>
        <ul class="menu">
          <li><a href="#" class="menu-title">menu-1-1</a></li>
          <li><a href="#" class="menu-title">menu-1-2</a></li>
        </ul>
      </li>
      <li>
        <a href="#" class="menu-title menu-header">menu-2</a>
        <ul class="menu">
          <li><a href="#" class="menu-title">menu-2-1</a></li>
          <li>
            <a href="#" class="menu-title">menu-2-2</a>
            <ul class="menu">
              <li><a href="#" class="menu-title">menu-2-2-1</a></li>
              <li>
                <a href="#" class="menu-title">menu-2-2-2</a>

              </li>
              <li><a href="#" class="menu-title">menu-2-2-3</a></li>
            </ul>
          </li>
          <li><a href="#" class="menu-title">menu-2-3</a></li>
        </ul>
      </li>
      <li>
        <a href="#" class="menu-title menu-header active">menu-3</a>
        <ul class="menu">
          <li><a href="#" class="menu-title">menu-3-1</a></li>
          <li><a href="#" class="menu-title">menu-3-2</a></li>
          <li><a href="#" class="menu-title">menu-3-3</a></li>
        </ul>
      </li>
    </ul>

    <h3> 下拉菜单 </h3>
    <ul class="menu menu-dropdown">
      <li>
        <a href="#" class="menu-title menu-header">menu-1</a>
        <ul class="menu">
          <li><a href="#" class="menu-title">menu-1-1</a></li>
          <li><a href="#" class="menu-title">menu-1-2</a></li>
        </ul>
      </li>
      <li>
        <a href="#" class="menu-title menu-header">menu-2</a>
        <ul class="menu">
          <li><a href="#" class="menu-title">menu-2-1</a></li>
          <li>
            <a href="#" class="menu-title">menu-2-2</a>
            <ul class="menu">
              <li><a href="#" class="menu-title">menu-2-2-1</a></li>
              <li>
                <a href="#" class="menu-title">menu-2-2-2</a>

              </li>
              <li><a href="#" class="menu-title">menu-2-2-3</a></li>
            </ul>
          </li>
          <li><a href="#" class="menu-title">menu-2-3</a></li>
        </ul>
      </li>
      <li>
        <a href="#" class="menu-title menu-header active">menu-3</a>
        <ul class="menu">
          <li><a href="#" class="menu-title">menu-3-1</a></li>
          <li><a href="#" class="menu-title">menu-3-2</a></li>
          <li><a href="#" class="menu-title">menu-3-3</a></li>
        </ul>
      </li>
    </ul>

    <h3> 目录菜单，最多支持6级目录结构 </h3>
    <ul class="menu menu-catalogue">
      <li>
        <a href="#" class="menu-title menu-header">menu-1</a>
        <ul class="menu menu-catalogue">
          <li><a href="#" class="menu-title">menu-1-1</a></li>
          <li><a href="#" class="menu-title">menu-1-2</a></li>
        </ul>
      </li>
      <li>
        <a href="#" class="menu-title menu-header">menu-2</a>
        <ul class="menu menu-catalogue">
          <li><a href="#" class="menu-title">menu-2-1</a></li>
          <li>
            <a href="#" class="menu-title">menu-2-2</a>
            <ul class="menu menu-catalogue">
              <li><a href="#" class="menu-title">menu-2-2-1</a></li>
              <li>
                <a href="#" class="menu-title">menu-2-2-2</a>

              </li>
              <li><a href="#" class="menu-title">menu-2-2-3</a></li>
            </ul>
          </li>
          <li><a href="#" class="menu-title">menu-2-3</a></li>
        </ul>
      </li>
      <li>
        <a href="#" class="menu-title menu-header active">menu-3</a>
        <ul class="menu menu-catalogue">
          <li><a href="#" class="menu-title">menu-3-1</a></li>
          <li><a href="#" class="menu-title">menu-3-2</a></li>
          <li><a href="#" class="menu-title">menu-3-3</a></li>
        </ul>
      </li>
    </ul>
  </section>

</div>

<script>
  $(function () {
    // util start
    /** @type {string|undefined} */
    let storedTransformPropertyName_;

    /**
     * Returns the name of the correct transform property to use on the current browser.
     * @param {!Window} globalObj
     * @param {boolean=} forceRefresh
     * @return {string}
     */
    function getTransformPropertyName(globalObj, forceRefresh = false) {
      if (storedTransformPropertyName_ === undefined || forceRefresh) {
        const el = globalObj.document.createElement('div');
        const transformPropertyName = ('transform' in el.style ? 'transform' : 'webkitTransform');
        storedTransformPropertyName_ = transformPropertyName;
      }

      return storedTransformPropertyName_;
    }

    /**
     * Clamps a value between the minimum and the maximum, returning the clamped value.
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @return {number}
     */
    function clamp(value, min = 0, max = 1) {
      return Math.min(max, Math.max(min, value));
    }


    /**
     * Returns the easing value to apply at time t, for a given cubic bezier curve.
     * Control points P0 and P3 are assumed to be (0,0) and (1,1), respectively.
     * Parameters are as follows:
     * - time: The current time in the animation, scaled between 0 and 1.
     * - x1: The x value of control point P1.
     * - y1: The y value of control point P1.
     * - x2: The x value of control point P2.
     * - y2: The y value of control point P2.
     * @param {number} time
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @return {number}
     */
    function bezierProgress(time, x1, y1, x2, y2) {
      return getBezierCoordinate_(solvePositionFromXValue_(time, x1, x2), y1, y2);
    }

    /**
     * Compute a single coordinate at a position point between 0 and 1.
     * c1 and c2 are the matching coordinate on control points P1 and P2, respectively.
     * Control points P0 and P3 are assumed to be (0,0) and (1,1), respectively.
     * Adapted from https://github.com/google/closure-library/blob/master/closure/goog/math/bezier.js.
     * @param {number} t
     * @param {number} c1
     * @param {number} c2
     * @return {number}
     */
    function getBezierCoordinate_(t, c1, c2) {
      // Special case start and end.
      if (t === 0 || t === 1) {
        return t;
      }

      // Step one - from 4 points to 3
      let ic0 = t * c1;
      let ic1 = c1 + t * (c2 - c1);
      const ic2 = c2 + t * (1 - c2);

      // Step two - from 3 points to 2
      ic0 += t * (ic1 - ic0);
      ic1 += t * (ic2 - ic1);

      // Final step - last point
      return ic0 + t * (ic1 - ic0);
    }

    /**
     * Project a point onto the Bezier curve, from a given X. Calculates the position t along the curve.
     * Adapted from https://github.com/google/closure-library/blob/master/closure/goog/math/bezier.js.
     * @param {number} xVal
     * @param {number} x1
     * @param {number} x2
     * @return {number}
     */
    function solvePositionFromXValue_(xVal, x1, x2) {
      const EPSILON = 1e-6;
      const MAX_ITERATIONS = 8;

      if (xVal <= 0) {
        return 0;
      } else if (xVal >= 1) {
        return 1;
      }

      // Initial estimate of t using linear interpolation.
      let t = xVal;

      // Try gradient descent to solve for t. If it works, it is very fast.
      let tMin = 0;
      let tMax = 1;
      let value = 0;
      for (let i = 0; i < MAX_ITERATIONS; i++) {
        value = getBezierCoordinate_(t, x1, x2);
        const derivative = (getBezierCoordinate_(t + EPSILON, x1, x2) - value) / EPSILON;
        if (Math.abs(value - xVal) < EPSILON) {
          return t;
        } else if (Math.abs(derivative) < EPSILON) {
          break;
        } else {
          if (value < xVal) {
            tMin = t;
          } else {
            tMax = t;
          }
          t -= (value - xVal) / derivative;
        }
      }

      // If the gradient descent got stuck in a local minimum, e.g. because
      // the derivative was close to 0, use a Dichotomy refinement instead.
      // We limit the number of interations to 8.
      for (let i = 0; Math.abs(value - xVal) > EPSILON && i < MAX_ITERATIONS; i++) {
        if (value < xVal) {
          tMin = t;
          t = (t + tMax) / 2;
        } else {
          tMax = t;
          t = (t + tMin) / 2;
        }
        value = getBezierCoordinate_(t, x1, x2);
      }
      return t;
    }
    // util end


    // 调整位置
    const radios = document.querySelectorAll('input[name="position"]');
    for (let i = 0; i < radios.length; i++) {
      radios[i].addEventListener('change', function (e) {
        if (e.target.checked) {
          const value = e.target.value;
          if (value) {
            const position = document.querySelector('.menu-demo-position');
            position.style.removeProperty('top');
            position.style.removeProperty('right');
            position.style.removeProperty('bottom');
            position.style.removeProperty('left');

            const vertical = value.split(' ')[0];
            const horizontal = value.split(' ')[1];
            position.style.setProperty(vertical, '1rem');
            position.style.setProperty(horizontal, '1rem');
          }
        }
      });
    }

    let animationRequestId;
    // Total duration of the menu animation.
    const TRANSITION_DURATION_MS = 300;
    // The time value the menu waits until the animation starts on the Y axis (0 - 1).
    const TRANSITION_SCALE_ADJUSTMENT_Y = 0.2;
    // The menu starts its open animation with the X axis at this time value (0 - 1).
    const TRANSITION_SCALE_ADJUSTMENT_X = 0.5;
    // The cubic bezier control points for the animation (cubic-bezier(0, 0, 0.2, 1)).
    const TRANSITION_X1 = 0;
    const TRANSITION_Y1 = 0;
    const TRANSITION_X2 = 0.2;
    const TRANSITION_Y2 = 1;

    const BOTTOM_LEFT = 'list-menu-bottom-left', BOTTOM_RIGHT = 'list-menu-bottom-right';
    const listMenu = $('#listMenuDemo');
    const itemsContainer = listMenu.find('.list-menu-items.list');
    const listMenuItems = listMenu.find('.list-item');

    let dimensions_ = null;
    let itemHeight_ = null;
    let scaleX_ = 0;
    let scaleY_ = 0;
    let startTime_ = null;
    let startScaleX_ = null;
    let startScaleY_ = null;
    let isOpen_ = false;
    let targetScale_ = 0;
    let running_ = false;
    let previousFocus_ = null;

    // 计算 menu 各 item 动画延迟时间
    function transitionDelays(dimensions) {
      const numItems = listMenuItems.length;
      const {height} = dimensions;
      const transitionDuration = TRANSITION_DURATION_MS / 1000;
      const start = TRANSITION_SCALE_ADJUSTMENT_Y;

      for (let index = 0; index < numItems; index++) {
        const {offsetTop: itemTop, offsetHeight: itemHeight} = listMenuItems[index];
        itemHeight_ = itemHeight;
        let itemDelayFraction = itemTop / height;
        if (listMenu.hasClass(BOTTOM_LEFT) || listMenu.hasClass(BOTTOM_RIGHT)) {
          itemDelayFraction = ((height - itemTop - itemHeight) / height);
        }
        const itemDelay = (start + itemDelayFraction * (1 - start)) * transitionDuration;
        // Use toFixed() here to normalize CSS unit precision across browsers
        listMenuItems[index].style.setProperty('transition-delay', `${itemDelay.toFixed(3)}s`);
      }
    }

    function autoPosition(dimensions) {
      // Defaults: open from the top left.
      let vertical = 'top';
      let horizontal = 'left';

      const anchorDimensions = listMenu[0].parentElement.getBoundingClientRect();
      const windowDimensions = {width: window.innerWidth, height: window.innerHeight};

      const topOverflow = anchorDimensions.top + dimensions.height - windowDimensions.height;
      const bottomOverflow = dimensions.height - anchorDimensions.bottom;
      const extendsBeyondTopBounds = topOverflow > 0;

      if (extendsBeyondTopBounds) {
        if (bottomOverflow < topOverflow) {
          vertical = 'bottom';
        }
      }

      const leftOverflow = anchorDimensions.left + dimensions.width - windowDimensions.width;
      const rightOverflow = dimensions.width - anchorDimensions.right;
      const extendsBeyondLeftBounds = leftOverflow > 0;

      if (extendsBeyondLeftBounds && rightOverflow < leftOverflow) {
        horizontal = 'right';
      }

      const position = {
        [horizontal]: '0',
        [vertical]: '0',
      };

      listMenu[0].style[`transform-origin`] = origin;

      listMenu[0].style.left = 'left' in position ? position.left : null;
      listMenu[0].style.right = 'right' in position ? position.right : null;
      listMenu[0].style.top = 'top' in position ? position.top : null;
      listMenu[0].style.bottom = 'bottom' in position ? position.bottom : null;

    }

    function animationLoop() {
      const time = window.performance.now();
      const currentTime = clamp((time - startTime_) / TRANSITION_DURATION_MS);

      // Animate X axis very slowly, so that only the Y axis animation is visible during fade-out.
      let currentTimeX = clamp(
        (currentTime - TRANSITION_SCALE_ADJUSTMENT_X) / (1 - TRANSITION_SCALE_ADJUSTMENT_X)
      );
      // No time-shifting on the Y axis when closing.
      let currentTimeY = currentTime;

      let startScaleY = startScaleY_;
      if (targetScale_ === 1) {
        // Start with the menu at the height of a single item.
        if (itemHeight_) {
          startScaleY = Math.max(itemHeight_ / dimensions_.height, startScaleY);
        }
        // X axis moves faster, so time-shift forward.
        currentTimeX = clamp(currentTime + TRANSITION_SCALE_ADJUSTMENT_X);
        // Y axis moves slower, so time-shift backwards and adjust speed by the difference.
        currentTimeY = clamp(
          (currentTime - TRANSITION_SCALE_ADJUSTMENT_Y) / (1 - TRANSITION_SCALE_ADJUSTMENT_Y)
        );
      }

      // Apply cubic bezier easing independently to each axis.
      const easeX = bezierProgress(currentTimeX, TRANSITION_X1, TRANSITION_Y1, TRANSITION_X2, TRANSITION_Y2);
      const easeY = bezierProgress(currentTimeY, TRANSITION_X1, TRANSITION_Y1, TRANSITION_X2, TRANSITION_Y2);

      // Calculate the scales to apply to the outer container and inner container.
      scaleX_ = startScaleX_ + (targetScale_ - startScaleX_) * easeX;
      const invScaleX = 1 / (scaleX_ === 0 ? 1 : scaleX_);
      scaleY_ = startScaleY + (targetScale_ - startScaleY) * easeY;
      const invScaleY = 1 / (scaleY_ === 0 ? 1 : scaleY_);

      // Apply scales.
      listMenu[0].style['transform'] = `scale(${scaleX_}, ${scaleY_})`;
      itemsContainer[0].style['transform'] = `scale(${invScaleX}, ${invScaleY})`;

      // Stop animation when we've covered the entire 0 - 1 range of time.
      if (currentTime < 1) {
        animationRequestId = requestAnimationFrame(() => animationLoop());
      } else {
        animationRequestId = 0;
        running_ = false;
        listMenu.removeClass('list-menu-animating');
      }
    }

    function animateMenu() {
      startTime_ = window.performance.now();
      startScaleX_ = scaleX_;
      startScaleY_ = scaleY_;

      targetScale_ = isOpen_ ? 1 : 0;

      if (!running_) {
        running_ = true;
        animationRequestId = requestAnimationFrame(() => animationLoop());
      }
    }

    function open() {
      listMenu.addClass('list-menu-animating');
      animationRequestId = requestAnimationFrame(() => {
        dimensions_ = {
          width: itemsContainer[0].offsetWidth,
          height: itemsContainer[0].offsetHeight
        };

        transitionDelays(dimensions_);
        autoPosition(dimensions_);
        animateMenu();

        listMenu.addClass('list-menu-open');
        //this.focusOnOpen_(focusIndex);
      });
    }

    function close() {
      listMenu.addClass('list-menu-animating');

      requestAnimationFrame(() => {
        const numItems = listMenuItems.length;
        for (let i = 0; i < numItems; i++) {
          listMenuItems[i].style.setProperty('transition-delay', null);
        }

        animateMenu();
        listMenu.removeClass('list-menu-open');
      });

      isOpen_ = false;
      if (previousFocus_) {
        previousFocus_.focus();
      }
    }

    document.body.addEventListener('click', () => {
      close();
    });
    $('#toggleMenu').click(function (e) {
      // 阻止冒泡
      e.stopPropagation();
      previousFocus_ = document.activeElement;
      if (isOpen_) {
        close();
      } else {
        open();
      }
      isOpen_ = !isOpen_;
    });

  });
</script>


